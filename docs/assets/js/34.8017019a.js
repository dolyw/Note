(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{469:function(t,_,v){"use strict";v.r(_);var e=v(20),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"mysql存储引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql存储引擎"}},[t._v("#")]),t._v(" MySQL存储引擎")]),t._v(" "),v("p",[t._v("存储引擎是数据库的核心，对于 MySQL 来说，存储引擎是以插件的形式运行的。虽然 MySQL 支持种类繁多的存储引擎，但是常用的就那么几种")]),t._v(" "),v("h2",{attrs:{id:"_1-存储引擎介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-存储引擎介绍"}},[t._v("#")]),t._v(" 1. 存储引擎介绍")]),t._v(" "),v("p",[t._v("MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复")]),t._v(" "),v("p",[t._v("5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB")]),t._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 MySQL 提供的所有存储引擎")]),t._v("\nmysql"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" show engines"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 MySQL 当前默认的存储引擎")]),t._v("\nmysql"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" show variables like "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%storage_engine%'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看表的存储引擎")]),t._v("\nmysql"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" show table status like "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"table_name"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("h2",{attrs:{id:"_2-myisam和innodb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-myisam和innodb"}},[t._v("#")]),t._v(" 2. MyISAM和InnoDB")]),t._v(" "),v("blockquote",[v("p",[t._v("介绍")])]),t._v(" "),v("h3",{attrs:{id:"_2-1-myisam"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-myisam"}},[t._v("#")]),t._v(" 2.1. MyISAM")]),t._v(" "),v("p",[t._v("MySQL 5.5 版本之前的默认存储引擎，在 "),v("code",[t._v("5.0")]),t._v(" 以前最大表存储空间最大 "),v("code",[t._v("4G")]),t._v("，"),v("code",[t._v("5.0")]),t._v(" 以后最大 "),v("code",[t._v("256TB")]),t._v("。由 "),v("code",[t._v(".myd")]),t._v("（数据）和 "),v("code",[t._v(".myi")]),t._v("（索引文件）组成，"),v("code",[t._v(".frm")]),t._v("文件存储表结构（所以存储引擎都有）")]),t._v(" "),v("p",[v("strong",[t._v("特性")])]),t._v(" "),v("ul",[v("li",[t._v("并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥）")]),t._v(" "),v("li",[t._v("表损坏修复")]),t._v(" "),v("li",[t._v("Myisam 表支持的索引类型（全文索引）")]),t._v(" "),v("li",[t._v("Myisam 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩）")])]),t._v(" "),v("p",[v("strong",[t._v("应用场景")])]),t._v(" "),v("ul",[v("li",[t._v("没有事务")]),t._v(" "),v("li",[t._v("只读类应用（插入不频繁，查询非常频繁）")]),t._v(" "),v("li",[t._v("空间类应用（唯一支持空间函数的引擎）")]),t._v(" "),v("li",[t._v("做很多 count 的计算")])]),t._v(" "),v("h3",{attrs:{id:"_2-2-innodb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-innodb"}},[t._v("#")]),t._v(" 2.2. InnoDB")]),t._v(" "),v("p",[t._v("MySQL 5.5 及之后版本的默认存储引擎")]),t._v(" "),v("p",[v("strong",[t._v("特性")])]),t._v(" "),v("ul",[v("li",[t._v("InnoDB为事务性存储引擎")]),t._v(" "),v("li",[t._v("完全支持事物的 ACID 特性")]),t._v(" "),v("li",[t._v("Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚）")]),t._v(" "),v("li",[t._v("InnoDB支持行级锁")]),t._v(" "),v("li",[t._v("行级锁可以最大程度的支持并发")]),t._v(" "),v("li",[t._v("行级锁是由存储引擎层实现的")])]),t._v(" "),v("p",[v("strong",[t._v("应用场景")])]),t._v(" "),v("ul",[v("li",[t._v("可靠性要求比较高，或者要求事务")]),t._v(" "),v("li",[t._v("表更新和查询都相当的频繁，并且行锁定的机会比较大的情况")])]),t._v(" "),v("h3",{attrs:{id:"_2-3-对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-对比"}},[t._v("#")]),t._v(" 2.3. 对比")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("区别")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("InnoDB")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("MyISAM")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("事务")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("安全")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("非安全")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("锁")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("行级")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("表级")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("索引")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("聚集索引")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("非聚集索引")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("外键")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不支持")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("崩溃恢复")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不支持")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("场景")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("需要事务，大量增、改")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("多查询，不需要事务")])])])]),t._v(" "),v("p",[v("strong",[t._v("事务")])]),t._v(" "),v("ul",[v("li",[t._v("MyISAM 不提供事务支持")]),t._v(" "),v("li",[t._v("InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力")])]),t._v(" "),v("p",[v("strong",[t._v("锁")])]),t._v(" "),v("ul",[v("li",[t._v("MyISAM 只有表级锁(table-level locking)")]),t._v(" "),v("li",[t._v("InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁")])]),t._v(" "),v("p",[t._v("也就说，MyISAM 一锁就是锁住了整张表，所以在并发写的情况下效率比较低，而 InnoDB 在并发写的时候，性能更强")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("表级锁")]),t._v(" "),v("p",[t._v("MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁")])]),t._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[t._v("行级锁")]),t._v(" "),v("p",[t._v("MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁")])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("锁的算法")]),t._v(" "),v("ul",[v("li",[t._v("Record lock：记录锁，单个行记录上的锁")]),t._v(" "),v("li",[t._v("Gap lock：间隙锁，锁定一个范围，不包括记录本身")]),t._v(" "),v("li",[t._v("Next-key lock：record+gap临键锁，锁定一个范围，包含记录本身")]),t._v(" "),v("li",[v("strong",[t._v("详细查看："),v("RouterLink",{attrs:{to:"/database/01-MySQL-Lock.html#_4-2-间隙锁-gap-lock"}},[t._v("MySQL的那些锁-InnoDB锁算法")])],1)])])]),t._v(" "),v("p",[v("strong",[t._v("MVCC")])]),t._v(" "),v("ul",[v("li",[t._v("MyISAM 不支持，连行级锁都不支持，肯定不支持 MVCC")]),t._v(" "),v("li",[t._v("InnoDB 支持，MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能")])]),t._v(" "),v("p",[v("strong",[t._v("索引")])]),t._v(" "),v("ul",[v("li",[t._v("MyISAM 是非聚集索引，支持全文索引")]),t._v(" "),v("li",[t._v("InnoDB 是聚集索引，不支持全文索引")])]),t._v(" "),v("p",[v("strong",[t._v("外键")])]),t._v(" "),v("ul",[v("li",[t._v("MyISAM 不支持")]),t._v(" "),v("li",[t._v("InnoDB 支持")])]),t._v(" "),v("p",[t._v("一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定")]),t._v(" "),v("p",[v("strong",[t._v("是否支持数据库异常崩溃后的安全恢复")])]),t._v(" "),v("ul",[v("li",[t._v("MyISAM 不支持")]),t._v(" "),v("li",[t._v("InnoDB 支持，数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 "),v("code",[t._v("redo log")])])]),t._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[t._v("崩溃恢复")]),t._v(" "),v("ul",[v("li",[t._v("InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性")]),t._v(" "),v("li",[t._v("InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性，默认支持的隔离级别是 Repeatable Read")]),t._v(" "),v("li",[t._v("保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障")])])]),t._v(" "),v("h3",{attrs:{id:"_2-4-myisam和innodb的选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-myisam和innodb的选择"}},[t._v("#")]),t._v(" 2.4. MyISAM和InnoDB的选择")]),t._v(" "),v("p",[t._v("大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）")]),t._v(" "),v("p",[t._v("《MySQL 高性能》上面有一句话这样写到:")]),t._v(" "),v("blockquote",[v("p",[t._v("不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用")])]),t._v(" "),v("p",[t._v("一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的")]),t._v(" "),v("p",[t._v("因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎")]),t._v(" "),v("h2",{attrs:{id:"_3-其他存储引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-其他存储引擎"}},[t._v("#")]),t._v(" 3. 其他存储引擎")]),t._v(" "),v("blockquote",[v("p",[t._v("其他存储引擎介绍")])]),t._v(" "),v("h3",{attrs:{id:"_3-1-csv"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-csv"}},[t._v("#")]),t._v(" 3.1. CSV")]),t._v(" "),v("p",[v("strong",[t._v("文件系统存储特点")])]),t._v(" "),v("ul",[v("li",[t._v("数据以文本方式存储在文件中")]),t._v(" "),v("li",[v("code",[t._v(".csv")]),t._v("文件存储表内容")]),t._v(" "),v("li",[v("code",[t._v(".csm")]),t._v("文件存储表的元数据，如表状态和数据量")]),t._v(" "),v("li",[v("code",[t._v(".frm")]),t._v("存储表的结构")])]),t._v(" "),v("p",[v("strong",[t._v("CSV存储引擎特点")])]),t._v(" "),v("ul",[v("li",[t._v("以 CSV 格式进行数据存储")]),t._v(" "),v("li",[t._v("所有列必须都是不能为 NULL")]),t._v(" "),v("li",[t._v("不支持索引")]),t._v(" "),v("li",[t._v("可以对数据文件直接编辑（其他引擎是二进制存储，不可编辑）")])]),t._v(" "),v("p",[v("strong",[t._v("引用场景")])]),t._v(" "),v("ul",[v("li",[t._v("作为数据交换的中间表")])]),t._v(" "),v("h3",{attrs:{id:"_3-2-archive"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-archive"}},[t._v("#")]),t._v(" 3.2. Archive")]),t._v(" "),v("p",[v("strong",[t._v("特性")])]),t._v(" "),v("ul",[v("li",[t._v("以 zlib 对表数据进行压缩，磁盘 I/O 更少")]),t._v(" "),v("li",[t._v("数据存储在ARZ为后缀的文件中（表文件为 "),v("code",[t._v("a.arz")]),t._v("，"),v("code",[t._v("a.frm")]),t._v("）")]),t._v(" "),v("li",[t._v("只支持 insert 和 select 操作（不可以 delete 和 update，会提示没有这个功能）")]),t._v(" "),v("li",[t._v("只允许在自增ID列上加索引")])]),t._v(" "),v("p",[v("strong",[t._v("应用场景")])]),t._v(" "),v("ul",[v("li",[t._v("日志和数据采集类应用")])]),t._v(" "),v("h3",{attrs:{id:"_3-3-memory"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-memory"}},[t._v("#")]),t._v(" 3.3. Memory")]),t._v(" "),v("p",[v("strong",[t._v("特性")])]),t._v(" "),v("ul",[v("li",[t._v("也称为 HEAP 存储引擎，所以数据保存在内存中（数据库重启后会导致数据丢失）")]),t._v(" "),v("li",[t._v("支持 HASH 索引（等值查找应选择 HASH）和 BTree 索引（范围查找应选择）")]),t._v(" "),v("li",[t._v("所有字段都为固定长度，varchar(10) == char(10)")]),t._v(" "),v("li",[t._v("不支持 BLOG 和 TEXT 等大字段")]),t._v(" "),v("li",[t._v("Memory 存储使用表级锁（性能可能不如 innodb）")]),t._v(" "),v("li",[t._v("最大大小由 "),v("code",[t._v("max_heap_table_size")]),t._v(" 参数决定")]),t._v(" "),v("li",[t._v("Memory存储引擎默认表大小只有 "),v("code",[t._v("16M")]),t._v("，可以通过调整 "),v("code",[t._v("max_heap_table_size")]),t._v(" 参数")])]),t._v(" "),v("p",[v("strong",[t._v("应用场景")])]),t._v(" "),v("ul",[v("li",[t._v("用于查找或是映射表，例如右边和地区的对应表")]),t._v(" "),v("li",[t._v("用于保存数据分析中产生的中间表")]),t._v(" "),v("li",[t._v("用于缓存周期性聚合数据的结果表")])]),t._v(" "),v("p",[v("strong",[t._v("注意：")]),t._v(" Memory 数据易丢失，所以要求数据可再生")]),t._v(" "),v("h3",{attrs:{id:"_3-4-federated"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-federated"}},[t._v("#")]),t._v(" 3.4. Federated")]),t._v(" "),v("p",[v("strong",[t._v("特性")])]),t._v(" "),v("ul",[v("li",[t._v("提供了访问远程 MySQL 服务器上表的方法")]),t._v(" "),v("li",[t._v("本地不存储数据，数据全部放在远程服务器上")])]),t._v(" "),v("p",[v("strong",[t._v("使用 Federated")])]),t._v(" "),v("p",[t._v("默认是禁止的。如果需要启用，需要在启动时增加Federated参数")]),t._v(" "),v("h2",{attrs:{id:"_4-独立表空间和系统表空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-独立表空间和系统表空间"}},[t._v("#")]),t._v(" 4. 独立表空间和系统表空间")]),t._v(" "),v("p",[v("strong",[t._v("两者比较")])]),t._v(" "),v("ul",[v("li",[t._v("系统表空间：无法简单的收缩大小（这很恐怖，会导致 ibdata1 一直增大，即使删除了数据也不会变小）")]),t._v(" "),v("li",[t._v("独立表空间：可以通过 optimize table 命令收缩系统文件")]),t._v(" "),v("li",[t._v("系统表空间：会产生I/O瓶颈（因为只有一个文件）")]),t._v(" "),v("li",[t._v("独立表空间：可以向多个文件刷新数据")])]),t._v(" "),v("p",[v("strong",[t._v("总结")])]),t._v(" "),v("p",[t._v("强烈建议：对Innodb引擎使用独立表空间（mysql5.6版本以后默认是独立表空间）")]),t._v(" "),v("p",[v("strong",[t._v("系统表转移为独立表的步骤（非常繁琐）")])]),t._v(" "),v("ul",[v("li",[t._v("使用 mysqldump 导出所有数据库表数据")]),t._v(" "),v("li",[t._v("停止 mysql 服务，修改参数，并且删除Innodb相关文件")]),t._v(" "),v("li",[t._v("重启 mysql 服务，重建mysql系统表空间")]),t._v(" "),v("li",[t._v("重新导入数据")])]),t._v(" "),v("p",[v("strong",[t._v("参考")])]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://github.com/frank-lam/fullstack-tutorial/blob/master/notes/MySQL.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL知识点总结"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);