(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{502:function(t,r,_){"use strict";_.r(r);var e=_(20),a=Object(e.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浅析分布式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浅析分布式事务"}},[t._v("#")]),t._v(" 浅析分布式事务")]),t._v(" "),_("blockquote",[_("p",[t._v("浅析分布式事务")])]),t._v(" "),_("p",[t._v("一个大型业务系统往往由若干个子系统构成，这些子系统又拥有各自独立的数据库。往往一个业务流程需要由多个子系统共同完成，而且这些操作可能需要在一个事务中完成")]),t._v(" "),_("p",[t._v("在微服务系统中，这些业务场景是普遍存在的。此时，我们就需要在数据库之上通过某种手段，实现支持跨数据库的事务支持，这也就是大家常说的 - 分布式事务")]),t._v(" "),_("p",[t._v("分布式事务是由多个本地事务组成的，分布式事务跨越了多设备，之间又经历的复杂的网络，往往只能妥协到最终一致性，保证数据最终的完整性和一致性")]),t._v(" "),_("ul",[_("li",[_("RouterLink",{attrs:{to:"/database/00-Isolation.html"}},[t._v("ACID以及事务隔离级别")])],1),t._v(" "),_("li",[_("RouterLink",{attrs:{to:"/distributed/00-CAP-BASE.html"}},[t._v("CAP和BASE理论")])],1)]),t._v(" "),_("h2",{attrs:{id:"_1-事务模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务模型"}},[t._v("#")]),t._v(" 1. 事务模型")]),t._v(" "),_("p",[t._v("描述分布式事务，常常会使用以下几个名词")]),t._v(" "),_("ul",[_("li",[t._v("事务参与者：例如每个数据库就是一个事务参与者")]),t._v(" "),_("li",[t._v("事务协调者：访问多个数据源的服务程序")])]),t._v(" "),_("p",[t._v("一般专业的称呼如下")]),t._v(" "),_("ul",[_("li",[t._v("资源管理器：Resource Manager, RM - 通常与事务参与者同义")]),t._v(" "),_("li",[t._v("事务管理器：Transaction Manager, TM - 通常与事务协调者同义")])]),t._v(" "),_("p",[t._v("在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性")]),t._v(" "),_("h2",{attrs:{id:"_2-2pc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2pc"}},[t._v("#")]),t._v(" 2. 2PC")]),t._v(" "),_("p",[t._v("2PC，Two-phase commit protocol，即两阶段提交协议，分别有协调者和参与者两个角色，整体分为两个阶段，分别是准备阶段和提交/回滚阶段")]),t._v(" "),_("p",[_("strong",[t._v("准备阶段")])]),t._v(" "),_("p",[t._v("由事务协调者给每个参与者发送准备命令，每个参与者收到命令之后会执行相关事务操作，你可以认为除了事务的提交啥都做了，然后每个参与者会返回响应告知协调者自己是否准备成功，协调者收到每个参与者的响应之后就进入第二阶段")]),t._v(" "),_("p",[_("strong",[t._v("提交/回滚阶段")])]),t._v(" "),_("p",[t._v("根据收集的响应，如果有一个参与者响应准备失败那么就向所有参与者发送回滚命令，反之发送提交命令")]),t._v(" "),_("p",[_("strong",[t._v("超时机制")])]),t._v(" "),_("p",[t._v("事务协调者在第一阶段未收到个别参与者的响应，则等待一定时间就会认为事务失败，会发送回滚命令，所以在 2PC 中事务协调者有超时机制")]),t._v(" "),_("h3",{attrs:{id:"_2-1-同步阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-同步阻塞"}},[t._v("#")]),t._v(" 2.1. 同步阻塞")]),t._v(" "),_("p",[t._v("可以看到在第一阶段执行了准备命令后，我们每个本地资源都处于锁定状态，因为除了事务的提交之外啥都做了")]),t._v(" "),_("p",[t._v("所以这时候如果本地的其他请求要访问同一个资源，比如要修改商品表 id 等于 100 的那条数据，那么此时是被阻塞住的，必须等待前面事务的完结，收到提交/回滚命令执行完释放资源后，这个请求才能得以继续")]),t._v(" "),_("p",[t._v("所以假设这个分布式事务涉及到很多参与者，然后有些参与者处理又特别复杂，特别慢，那么那些处理快的节点也得等着，所以说效率有点低")]),t._v(" "),_("h3",{attrs:{id:"_2-2-单点故障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-单点故障"}},[t._v("#")]),t._v(" 2.2. 单点故障")]),t._v(" "),_("p",[t._v("可以看到这个单点就是协调者，如果协调者挂了整个事务就执行不下去了")]),t._v(" "),_("p",[t._v("如果协调者在发送准备命令前挂了还行，毕竟每个资源都还未执行命令，那么资源是没被锁定的")]),t._v(" "),_("p",[t._v("可怕的是在发送完准备命令之后挂了，这时候每个本地资源都执行完处于锁定状态了，都杵着了，这就很僵硬了，如果是某个热点资源都阻塞了，就会引发一系列问题")]),t._v(" "),_("h3",{attrs:{id:"_2-3-数据不一致问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-数据不一致问题"}},[t._v("#")]),t._v(" 2.3. 数据不一致问题")]),t._v(" "),_("p",[t._v("因为协调者和参与者之间的交流是经过网络的，而网络有时候就会抽风的或者发生局部网络异常")]),t._v(" "),_("p",[t._v("那么就有可能导致某些参与者无法收到协调者的请求，而某些收到了。比如是提交请求，然后那些收到命令的参与者就提交事务了，此时就产生了数据不一致的问题")]),t._v(" "),_("h3",{attrs:{id:"_2-4-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-总结"}},[t._v("#")]),t._v(" 2.4. 总结")]),t._v(" "),_("p",[t._v("2PC ，它是一个同步阻塞的强一致性两阶段提交协议")]),t._v(" "),_("p",[t._v("它的优势在于对业务没有侵入，可以利用数据库自身机制来进行事务的提交和回滚，也就是说提交和回滚实际操作不需要我们实现，不侵入业务逻辑由数据库完成")]),t._v(" "),_("p",[t._v("它的缺点是一个同步阻塞协议，会导致高延迟和性能的下降，并且存在协调者单点故障问题，极端情况下会有数据不一致的问题")]),t._v(" "),_("p",[t._v("当然这只是协议，具体的实现还是可以变通了，比如协调者单点问题，可以做主从来实现协调者防止单点")]),t._v(" "),_("h2",{attrs:{id:"x-二将军问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#x-二将军问题"}},[t._v("#")]),t._v(" X. 二将军问题")]),t._v(" "),_("p",[t._v("待补充")]),t._v(" "),_("p",[_("strong",[t._v("参考")])]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/7gfmnXQRRim0OCIRC0tQ5w",target:"_blank",rel:"noopener noreferrer"}},[t._v("阿里终面：分布式事务原理"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/LDocAwC3CiKowvuoRBEdew",target:"_blank",rel:"noopener noreferrer"}},[t._v("两天，我把分布式事务搞完了"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/I48GBKLwQLFrL5y_yJDa0Q",target:"_blank",rel:"noopener noreferrer"}},[t._v("消息队列之事务消息，RocketMQ 和 Kafka是如何做的？"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://juejin.im/post/6844903573667446797",target:"_blank",rel:"noopener noreferrer"}},[t._v("常用的分布式事务解决方案"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.cnblogs.com/monkeyblog/p/10449363.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于分布式事务，XA协议的学习笔记"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://blog.csdn.net/qq_42332821/article/details/104503326",target:"_blank",rel:"noopener noreferrer"}},[t._v("分布式事务TCC和XA有什么区别及TCC模型和DTP模型的区别"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/-MQZh4w2OA2RujC5sBD9Vw",target:"_blank",rel:"noopener noreferrer"}},[t._v("七种分布式事务的解决方案，一次讲给你听"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=a.exports}}]);