(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{205:function(v,_,t){"use strict";t.r(_);var r=t(0),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"java中的线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中的线程安全"}},[v._v("#")]),v._v(" Java中的线程安全")]),v._v(" "),t("p",[v._v("简单的介绍在Java中的线程安全(Thread-Safe)和线程不安全以及线程安全和不安全的集合对象，还有一个通俗易懂的小例子")]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("ul",[t("li",[v._v("如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的")])]),v._v(" "),t("h2",{attrs:{id:"工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[v._v("#")]),v._v(" 工作原理")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("JVM")]),v._v("有一个"),t("strong",[v._v("Main Memory")]),v._v("，而每个线程有自己的"),t("strong",[v._v("Working Memory")]),v._v("，一个线程对一个变量进行操作时，都要在自己的"),t("strong",[v._v("Working Memory")]),v._v("里面建立一个"),t("strong",[v._v("Copy")]),v._v("，操作完之后再写入"),t("strong",[v._v("Main Memory")]),v._v("。多个线程同时操作同一个变量，就可能会出现不可预知的结果。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性(多个线程先后更改数据造成所得到的数据是脏数据)")])]),v._v(" "),t("h2",{attrs:{id:"解决方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[v._v("#")]),v._v(" 解决方法")]),v._v(" "),t("blockquote",[t("p",[v._v("多线程并发不安全的原因已经知道，那么针对这个种情况，有两种解决思路")])]),v._v(" "),t("ul",[t("li",[v._v("给共享的资源加把锁，保证每个资源变量每时每刻至多被一个线程占用")]),v._v(" "),t("li",[v._v("让线程也拥有资源(副本)，不用去共享进程中的资源(副本)")])]),v._v(" "),t("blockquote",[t("p",[v._v("基于上面的两种思路，下面便是三种实施方案")])]),v._v(" "),t("ul",[t("li",[v._v("多实例或者是多副本("),t("strong",[v._v("ThreadLocal")]),v._v(")，对应着思路二，"),t("strong",[v._v("ThreadLocal")]),v._v("可以为每个线程的维护一个私有的本地变量，可参考"),t("strong",[v._v("Java")]),v._v("线程副本–"),t("strong",[v._v("ThreadLocal")])]),v._v(" "),t("li",[v._v("使用锁机制"),t("strong",[v._v("synchronize")]),v._v("或"),t("strong",[v._v("lock")]),v._v("方式，为资源加锁")]),v._v(" "),t("li",[v._v("使用"),t("strong",[v._v("java.util.concurrent")]),v._v("下面的类库，有"),t("strong",[v._v("JDK")]),v._v("提供的线程安全的集合类")])]),v._v(" "),t("h3",{attrs:{id:"线程安全的集合对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全的集合对象"}},[v._v("#")]),v._v(" 线程安全的集合对象")]),v._v(" "),t("ul",[t("li",[v._v("Vector")]),v._v(" "),t("li",[v._v("HashTable")]),v._v(" "),t("li",[v._v("StringBuffer")])]),v._v(" "),t("h3",{attrs:{id:"非线程安全的集合对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非线程安全的集合对象"}},[v._v("#")]),v._v(" 非线程安全的集合对象")]),v._v(" "),t("ul",[t("li",[v._v("ArrayList")]),v._v(" "),t("li",[v._v("LinkedList")]),v._v(" "),t("li",[v._v("HashMap")]),v._v(" "),t("li",[v._v("HashSet")]),v._v(" "),t("li",[v._v("TreeMap")]),v._v(" "),t("li",[v._v("TreeSet")]),v._v(" "),t("li",[v._v("StringBulider")])]),v._v(" "),t("h2",{attrs:{id:"举例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#举例"}},[v._v("#")]),v._v(" 举例")]),v._v(" "),t("ul",[t("li",[v._v("在单线程运行的情况下，如果"),t("strong",[v._v("Size = 0")]),v._v("，添加一个元素后，此元素在位"),t("strong",[v._v("0")]),v._v("，而且"),t("strong",[v._v("Size = 1")])]),v._v(" "),t("li",[v._v("如果是在多线程情况下，比如有两个线程，"),t("strong",[v._v("线程A")]),v._v("先将元素存放在位置0。但是此时"),t("strong",[v._v("CPU")]),v._v("调度"),t("strong",[v._v("线程A")]),v._v("暂停，"),t("strong",[v._v("线程B")]),v._v("得到运行的机会。"),t("strong",[v._v("线程B")]),v._v("也向此"),t("strong",[v._v("ArrayList")]),v._v("添加元素，因为此时"),t("strong",[v._v("Size")]),v._v("仍然等于"),t("strong",[v._v("0")]),v._v("(注意哦，我们假设的是添加一个元素是要两个步骤哦，而"),t("strong",[v._v("线程A")]),v._v("仅仅完成了步骤1)，所以"),t("strong",[v._v("线程B")]),v._v("也将元素存放在"),t("strong",[v._v("位置0")]),v._v("。然后"),t("strong",[v._v("线程A")]),v._v("和"),t("strong",[v._v("线程B")]),v._v("都继续运行，都增加"),t("strong",[v._v("Size")]),v._v("的值。那好，现在我们来看看"),t("strong",[v._v("ArrayList")]),v._v("的情况，元素实际上只有一个，存放在位置"),t("strong",[v._v("0")]),v._v("，而"),t("strong",[v._v("Size")]),v._v("却等于"),t("strong",[v._v("2")]),v._v("。这就是"),t("strong",[v._v("线程不安全")]),v._v("了")])])])}),[],!1,null,null,null);_.default=s.exports}}]);