(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{505:function(e,t,r){"use strict";r.r(t);var a=r(20),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"浅析分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浅析分布式锁"}},[e._v("#")]),e._v(" 浅析分布式锁")]),e._v(" "),r("p",[e._v("由于使用 Java 提供的 Synchronized 或者 ReentrantLock 只能锁住当前机器的线程，所以引出了分布式锁的概念")]),e._v(" "),r("div",{staticClass:"custom-block danger"},[r("p",{staticClass:"custom-block-title"},[e._v("实现方式")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("DB")]),e._v(": 一般使用都是乐观锁，悲观锁不考虑")]),e._v(" "),r("li",[r("strong",[e._v("Memcached")]),e._v(": 使用 add 命令。此命令是原子性操作，只有在 key 不存在的情况下，才能 add 成功，也就意味着线程得到了锁")]),e._v(" "),r("li",[r("strong",[e._v("Redis")]),e._v(": 使用 Redis 的 setnx 命令。此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功")]),e._v(" "),r("li",[r("strong",[e._v("Zookeeper")]),e._v(": 使用顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的")]),e._v(" "),r("li",[r("strong",[e._v("Chubby")]),e._v(": Google 公司实现的粗粒度分布式锁服务，底层利用了 Paxos 一致性算法")])])]),e._v(" "),r("p",[e._v("比较成熟主流常用的一般是 Redis 和 Zookeeper，这里说明下这两种的实现方式")]),e._v(" "),r("h2",{attrs:{id:"_1-redis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis"}},[e._v("#")]),e._v(" 1. Redis")]),e._v(" "),r("p",[e._v("原生实现和 Redisson 框架")]),e._v(" "),r("h3",{attrs:{id:"_1-1-原生实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-原生实现"}},[e._v("#")]),e._v(" 1.1. 原生实现")]),e._v(" "),r("p",[e._v("需要使用 setnx 命令，key 是锁的唯一标识，按业务来决定命名，还得设置过期时间防止死锁，但是 setnx 指令本身是不支持传入超时时间的，而 setnx 和 expire 两个操作合并是非原子性的，怎么解决呢")]),e._v(" "),r("ul",[r("li",[e._v("可以使用 lua 脚本，两个命令组合在一起就是原子的")]),e._v(" "),r("li",[e._v('Redis 从 2.6.12 版本开始 set 指令增加了可选参数：set(key, value, "NX", "PX", 1000 * 60)')])]),e._v(" "),r("p",[e._v("业务执行完成的时候，del 导致误删其他线程的锁，value 需要设置为当前线程的唯一值，del 的时候判断是不是当前线程的锁，是的话才进行删除，这样又是两个操作组合不是原子性了，怎么解决呢，这里只能依赖 lua 脚本解决")]),e._v(" "),r("div",{staticClass:"language-lua extra-class"},[r("pre",{pre:!0,attrs:{class:"language-lua"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("-- 获取锁")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("-- NX 是指如果 key 不存在就成功，key 存在返回 false，PX 可以指定过期时间")]),e._v("\nSET anyLock unique_value NX PX "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("30000")]),e._v("\n\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("-- 释放锁：通过执行一段 lua 脚本")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("-- 释放锁涉及到两条指令，这两条指令不是原子性的")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("-- 需要用到 redis 的 lua 脚本支持特性，redis 执行 lua 脚本是原子性的")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" redis"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("call")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"get"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" KEYS"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("==")]),e._v(" ARGV"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("then")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" redis"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("call")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"del"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" KEYS"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("end")]),e._v("\n")])])]),r("h3",{attrs:{id:"_1-2-redisson"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-redisson"}},[e._v("#")]),e._v(" 1.2. Redisson")]),e._v(" "),r("p",[e._v("Redisson 配置好直接使用即可，配置文件参考")]),e._v(" "),r("ul",[r("li",[e._v("Github: "),r("a",{attrs:{href:"https://github.com/dolyw/ProjectStudy/tree/master/SpringBoot/DelayTask",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/dolyw/ProjectStudy/tree/master/SpringBoot/DelayTask"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("Gitee(码云): "),r("a",{attrs:{href:"https://gitee.com/dolyw/ProjectStudy/tree/master/SpringBoot/DelayTask",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://gitee.com/dolyw/ProjectStudy/tree/master/SpringBoot/DelayTask"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("详细使用参考")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/130327922",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redisson实现分布式锁"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"_1-3-锁靠谱吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-锁靠谱吗"}},[e._v("#")]),e._v(" 1.3. 锁靠谱吗")]),e._v(" "),r("p",[e._v("Redis 分布式锁不是完全靠谱的，如果使用的是 Redis 集群，不是强一致性，可能存在异常")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/110923963",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis分布式锁可靠吗"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/142758586",target:"_blank",rel:"noopener noreferrer"}},[e._v("基于Redis实现分布式锁之前，这些坑你一定得知道"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"_2-zookeeper"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-zookeeper"}},[e._v("#")]),e._v(" 2. Zookeeper")]),e._v(" "),r("p",[e._v("Zookeeper 在 Java 中客户端有三种，Zookeeper 原生和 Apache Curator 框架，还有一个开源的 zkclient(使用率很低)，一般使用的都是 Curator，原生 API 使用起来没 Curator 方便")]),e._v(" "),r("h3",{attrs:{id:"_2-1-原生实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-原生实现"}},[e._v("#")]),e._v(" 2.1. 原生实现")]),e._v(" "),r("p",[e._v("ZooKeeper 可以创建 4 种类型的节点，分别是：持久性节点，持久性顺序节点，临时性节点，临时性顺序节点。Zookeeper 分布式锁的实现是基于临时性顺序节点来实现的，监听节点")]),e._v(" "),r("div",{staticClass:"custom-block danger"},[r("p",{staticClass:"custom-block-title"},[e._v("原理举例说明")]),e._v(" "),r("p",[e._v("假设服务器1，创建了一个节点 /zk1，成功了，那服务器1就获取了锁，服务器2再去创建相同的锁，就会失败，这个时候就只能监听这个节点的变化。等到服务器1处理完业务，删除了节点后，他就会得到通知，然后去创建同样的节点，获取锁处理业务，再删除节点，后续的 100 台服务器与之类似。注意这里的 100 台服务器并不是挨个去执行上面的创建节点的操作，而是并发的，当服务器1创建成功，那么剩下的 99 个就都会注册监听这个节点，等通知，以此类推。")]),e._v(" "),r("p",[e._v("但是大家有没有注意到，这里还是有问题的，还是会有死锁的情况存在，对不对？当服务器1创建了节点后挂了，没能删除，那其他99台服务器就会一直等通知，那就完蛋了，这个时候就需要用到临时性节点了，我们前面说过了，临时性节点的特点是客户端一旦断开，就会丢失，也就是当服务器1创建了节点后，如果挂了，那这个节点会自动被删除，这样后续的其他服务器，就可以继续去创建节点，获取锁了。")]),e._v(" "),r("p",[e._v("但是我们可能还需要注意到一点，就是惊群效应：举一个很简单的例子，当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到。就是当服务器1节点有变化，会通知其余的 99 个服务器，但是最终只有1个服务器会创建成功，这样 98 还是需要等待监听，那么为了处理这种情况，就需要用到临时顺序性节点。大致意思就是，之前是所有 99 个服务器都监听一个节点，现在就是每一个服务器监听自己前面的一个节点。")]),e._v(" "),r("p",[e._v("假设 100 个服务器同时发来请求，这个时候会在 /zkjjj 节点下创建 100 个临时顺序性节点 /zkjjj/000000001，/zkjjj/000000002，一直到 /zkjjj/000000100，这个编号就等于是已经给他们设置了获取锁的先后顺序了。当 001 节点处理完毕，删除节点后，002 收到通知，去获取锁，开始执行，执行完毕，删除节点，通知 003~100 以此类推")])]),e._v(" "),r("h3",{attrs:{id:"_2-2-curator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-curator"}},[e._v("#")]),e._v(" 2.2. Curator")]),e._v(" "),r("p",[e._v("Curator")]),e._v(" "),r("h3",{attrs:{id:"_2-3-锁靠谱吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-锁靠谱吗"}},[e._v("#")]),e._v(" 2.3. 锁靠谱吗")]),e._v(" "),r("p",[e._v("因为 Zookeeper 集群的写操作是线性一致性的(读是顺序一致性)，所以同时多个客户端进行写操作的话，出现异常的情况很低，比 Redis 更靠谱一些")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489062&idx=1&sn=e5e931c8f6a16ef18e34ca82f58aa9f2&source=41#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZooKeeper真不是最终一致性的，而是顺序一致性"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/42239873",target:"_blank",rel:"noopener noreferrer"}},[e._v("线性一致性：什么是线性一致性？"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"_3-总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[e._v("#")]),e._v(" 3. 总结")]),e._v(" "),r("ul",[r("li",[e._v("从理解的难度角度")])]),e._v(" "),r("p",[e._v("Zookeeper > 缓存 > 数据库")]),e._v(" "),r("ul",[r("li",[e._v("从实现的复杂性角度")])]),e._v(" "),r("p",[e._v("Zookeeper >= 缓存 > 数据库")]),e._v(" "),r("ul",[r("li",[e._v("从性能角度")])]),e._v(" "),r("p",[e._v("缓存 > Zookeeper >= 数据库")]),e._v(" "),r("ul",[r("li",[e._v("从可靠性角度")])]),e._v(" "),r("p",[e._v("Zookeeper > 缓存 > 数据库")]),e._v(" "),r("h2",{attrs:{id:"_4-封装"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-封装"}},[e._v("#")]),e._v(" 4. 封装")]),e._v(" "),r("p",[e._v("可以在锁的基础上再加一层封装，这样我们在从 ZK 替换到缓存，或者反过来的时候，改动点非常小")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/dvkklKG-4uQnoHN8gG3Z_Q",target:"_blank",rel:"noopener noreferrer"}},[e._v("分布式锁的封装也很有讲究呀"),r("OutboundLink")],1)])]),e._v(" "),r("p",[r("strong",[e._v("参考")])]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/a1ebab8ce78a",target:"_blank",rel:"noopener noreferrer"}},[e._v("什么是分布式锁"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://my.oschina.net/dengfuwei/blog/1600681",target:"_blank",rel:"noopener noreferrer"}},[e._v("spring boot redis分布式锁"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/qdhxhz/p/11046905.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redisson实现分布式锁(1)---原理"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/AnXinliang/p/10019389.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redisson实现Redis分布式锁的原理"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/eyesfree/p/13162863.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("分布式锁用 Redis 还是 Zookeeper？"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1476050",target:"_blank",rel:"noopener noreferrer"}},[e._v("分布式锁用Redis坚决不用Zookeeper？"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/LiZhiW/p/4923693.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("02.ZooKeeper的Java客户端使用"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/5T0nrf5LBSqOiPd99OB3tw",target:"_blank",rel:"noopener noreferrer"}},[e._v("阿里面试官：分布式锁到底用Redis好？还是Zookeeper好？"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/0jv2qg4RHmZBvZzI6vIikg",target:"_blank",rel:"noopener noreferrer"}},[e._v("通俗讲解分布式锁，看完不懂算作者输"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);